<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Dashboard</title>
    <link rel="stylesheet" th:href="@{/css/dashboard.css}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
</head>
<body>
    <!-- Header fragment -->
    <div th:replace="fragments/header :: header"></div>

    <!-- hidden room element for client-side scripts to read -->
    <span id="room" th:text="${room} ?: 'room1'" style="display:none">room1</span>

    <div class="dashboard-main">
        <h2 style="margin: 10px; padding-left: 25px;">Dashboard</h2>
        <div class="dashboard-grid">
            <!-- Row 1: Metric cards -->
            <div class="dashboard-card metric-card temp-card">
                <div class="card-title">Temperature <span>üå°Ô∏è</span></div>
                <div class="card-reading">
                    <span class="card-value" id="temperature" th:text="${temperature} ?: '--'">--</span>
                    <span class="card-unit">¬∞C</span>
                </div>
            </div>
            <div class="dashboard-card metric-card hum-card">
                <div class="card-title">Humidity <span>üíß</span></div>
                <div class="card-reading">
                    <span class="card-value" id="humidity" th:text="${humidity} ?: '--'">--</span>
                    <span class="card-unit">%</span>
                </div>
            </div>
            <div class="dashboard-card metric-card light-card">
                <div class="card-title">Light <span>üåû</span></div>
                <div class="card-reading">
                    <span class="card-value" id="lightLevel" th:text="${light} ?: '--'">--</span>
                    <span class="card-unit">Lux</span>
                </div>
            </div>
            <div class="dashboard-card metric-card rain-card">
                <div class="card-title">Rain <span>üåßÔ∏è</span></div>
                <div class="card-reading">
                    <span class="card-value" id="rain" th:text="${rain} ?: '--'">--</span>
                    <span class="card-unit">%</span>
                </div>
            </div>
            <div class="dashboard-card metric-card windy-card">
                <div class="card-title">Wind <span>üí®</span></div>
                <div class="card-reading">
                    <span class="card-value" id="windy" th:text="${windy} ?: '--'">--</span>
                    <span class="card-unit">km/h</span>
                </div>
            </div>
            <div class="dashboard-card device-card">
                <div class="card-title device-title">Device Control <img class="device-cloud" src="/images/cloud.png" alt="cloud"></div>
                <div class="device-control-group">
                    <div class="device-control-row">
                        <span class="device-label">ƒêi·ªÅu h√≤a</span>
                        <label class="switch">
                            <input type="checkbox" id="airToggle" onchange="toggleDevice('air', this.checked)" th:checked="${state != null and state.air != null and state.air.equalsIgnoreCase('ON')}">
                            <span class="slider"></span>
                        </label>
                        <img id="airIcon" class="device-icon" th:src="${state != null and state.air != null and state.air.equalsIgnoreCase('ON')} ? '/images/AirCon_Active.png' : '/images/AirCon_Not.png'" src="/images/AirCon_Not.png" alt="Air Conditioner">
                    </div>
                    <div class="device-control-row">
                        <span class="device-label">Qu·∫°t</span>
                        <label class="switch">
                            <input type="checkbox" id="fanToggle" onchange="toggleDevice('fan', this.checked)" th:checked="${state != null and state.fan != null and state.fan.equalsIgnoreCase('ON')}">
                            <span class="slider"></span>
                        </label>
                        <img id="fanIcon" class="device-icon" th:src="${state != null and state.fan != null and state.fan.equalsIgnoreCase('ON')} ? '/images/Fan_Act.png' : '/images/Fan_notAc.png'" src="/images/Fan_notAc.png" alt="Fan">
                    </div>
                    <div class="device-control-row">
                        <span class="device-label">ƒê√®n</span>
                        <label class="switch">
                            <input type="checkbox" id="lightToggle" onchange="toggleDevice('light', this.checked)" th:checked="${state != null and state.light != null and state.light.equalsIgnoreCase('ON')}">
                            <span class="slider"></span>
                        </label>
                        <img id="lightIcon" class="device-icon" th:src="${state != null and state.light != null and state.light.equalsIgnoreCase('ON')} ? '/images/Light_act.png' : '/images/Light_notAct.png'" src="/images/Light_notAct.png" alt="Light">
                    </div>
                </div>
            </div>

            <!-- Row 2: Chart wrappers (only containers for now) -->
            <div class="chart-wrapper chart-wrapper-temp-hum">
                <div class="dashboard-chart chart-temp-hum">
                    <canvas id="tempHumChart"></canvas>
                </div>
            </div>

        </div>

        <div id="cmdStatus" class="cmd-status" style="margin-left:25px">Ch∆∞a g·ª≠i l·ªánh</div>
        <button onclick="forceRefreshState()" style="margin:10px 25px;padding:8px 16px;cursor:pointer">üîÑ Refresh Device State</button>
    </div>

    
    <script th:inline="javascript">
        /*<![CDATA[*/
        document.addEventListener('DOMContentLoaded', () => {
            const url = new URL(`/api/data_sensor/stream/${document.getElementById('room').textContent || 'room1'}`, window.location.origin);
            console.log('Connecting SSE to:', url.href);

            const es = new EventSource(url.href /* , { withCredentials: true } */);

            es.onopen = () => console.log('SSE open');

            // n·∫øu server kh√¥ng ƒë·∫∑t name cho event th√¨ onmessage s·∫Ω nh·∫≠n
            es.onmessage = (e) => {
                console.log('onmessage:', e.data);
                try {
                    const d = JSON.parse(e.data);
                    update(d);
                } catch (err) {
                    console.warn('non-JSON message:', e.data);
                }
            };

            // n·∫øu server d√πng .name("sensor")
            es.addEventListener('sensor', (e) => {
                console.log('sensor event:', e.data);
                update(JSON.parse(e.data));
            });

            es.onerror = (e) => {
                console.error('SSE error', e);
                // kh√¥ng close, ƒë·ªÉ browser auto-reconnect
            };

            // create global element references so functions outside this block (toggleDevice, updateDeviceIcon)
            // can access them without throwing ReferenceErrors. Use window.* so they're available globally.
            window.temperature = document.getElementById('temperature');
            window.humidity = document.getElementById('humidity');
            window.lightLevel = document.getElementById('lightLevel');
            window.rain = document.getElementById('rain');
            window.windy = document.getElementById('windy');
            // timestamp element is optional (was previously commented out in the template); guard its usage
            window.timestamp = document.getElementById('timestamp');
            window.cmdStatus = document.getElementById('cmdStatus');
            window.airIcon = document.getElementById('airIcon');
            window.fanIcon = document.getElementById('fanIcon');
            window.lightIcon = document.getElementById('lightIcon');

            // Chart setup
            const MAX_POINTS = 10; // gi·ªØ l·∫°i N ƒëi·ªÉm g·∫ßn nh·∫•t

            const tempHumCtx = document.getElementById('tempHumChart').getContext('2d');

            // Prepare initial data from server (if any)
            // latestTenForDashboard is injected server-side as an array of objects
            const serverSeed = /*[[${latestTenForDashboard}]]*/ [];
            // sort ascending by timestamp
            serverSeed.sort(function(a,b){ return new Date(a.timestamp) - new Date(b.timestamp); });
            // normalize/round incoming seed data so charts are stable:
            // - round light values to integers (avoid tiny decimals causing big visual spikes)
            // - ensure temperature/humidity are numbers (we'll fix axes to 0..100)
            serverSeed.forEach(p => {
                if(p.lightLevel != null) try{ p.lightLevel = Math.round(Number(p.lightLevel)); }catch(e){}
                if(p.temperature != null) try{ p.temperature = Number(p.temperature); }catch(e){}
                if(p.humidity != null) try{ p.humidity = Number(p.humidity); }catch(e){}
                if(p.rain != null) try{ p.rain = Math.round(Number(p.rain)); }catch(e){}
                if(p.windy != null) try{ p.windy = Math.round(Number(p.windy)); }catch(e){}
            });
            console.log('serverSeed (preloaded, normalized):', serverSeed);

            const tempHumChart = new Chart(tempHumCtx, {
                type: 'line',
                data: {
                    labels: serverSeed.map(p => new Date(p.timestamp).toLocaleTimeString()),
                    datasets: [
                        { label: 'Temperature (¬∞C)', data: serverSeed.map(p => p.temperature), borderColor: '#e05656', backgroundColor: 'rgba(224,86,86,.25)', tension: .3, pointRadius: 3, yAxisID: 'left' },
                        { label: 'Humidity (%)',     data: serverSeed.map(p => p.humidity),    borderColor: '#33b5ff', backgroundColor: 'rgba(51,181,255,.25)', tension: .3, pointRadius: 3, yAxisID: 'left' },
                        { label: 'Light (Lux)',      data: serverSeed.map(p => p.lightLevel),  borderColor: '#c9a800', backgroundColor: 'rgba(201,168,0,.25)', tension: .3, pointRadius: 2, cubicInterpolationMode: 'monotone', spanGaps: true, yAxisID: 'right' },
                        { label: 'Rain (%)',         data: serverSeed.map(p => p.rain),        borderColor: '#4a90e2', backgroundColor: 'rgba(74,144,226,.25)', tension: .3, pointRadius: 3, yAxisID: 'left' },
                        { label: 'Wind (km/h)',      data: serverSeed.map(p => p.windy),       borderColor: '#95a5a6', backgroundColor: 'rgba(149,165,166,.25)', tension: .3, pointRadius: 3, yAxisID: 'left' }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: { ticks: { maxRotation: 50, minRotation: 50 } },
                        // fixed 0..100 axis for temperature and humidity as requested
                        left: { type: 'linear', position: 'left', beginAtZero: true, min: 0, max: 100, ticks: { stepSize: 10 }, grid: { drawOnChartArea: true } },
                        // light axis: begin at 0, prefer integer ticks and allow automatic max
                        right: { type: 'linear', position: 'right', beginAtZero: true, ticks: { precision: 0 }, grid: { drawOnChartArea: false } }
                    },
                    plugins: { legend: { position: 'top' } }
                }
            });

            function pushPoint(chart, label, values) {
                chart.data.labels.push(label);
                // ensure each dataset gets a value (or null if not provided)
                chart.data.datasets.forEach((ds, i) => {
                    const v = (values && typeof values[i] !== 'undefined') ? values[i] : null;
                    ds.data.push(v);
                });
                if (chart.data.labels.length > MAX_POINTS) {
                    chart.data.labels.shift();
                    chart.data.datasets.forEach(ds => ds.data.shift());
                }
                chart.update();
            }

            function fmtTime(ts) {
                try {
                    const d = ts ? new Date(ts) : new Date();
                    const hh = String(d.getHours()).padStart(2,'0');
                    const mm = String(d.getMinutes()).padStart(2,'0');
                    const ss = String(d.getSeconds()).padStart(2,'0');
                    return `${hh}:${mm}:${ss}`;
                } catch { return '--:--:--'; }
            }

            // Color helpers
            function toHex(v){
                const h = Math.max(0, Math.min(255, Math.round(v))).toString(16);
                return h.length===1?('0'+h):h;
            }

            // darken a hex color by fraction (0..1)
            function darkenHex(hex, frac){
                try{
                    const h = hex.replace('#','');
                    const r = parseInt(h.substring(0,2),16);
                    const g = parseInt(h.substring(2,4),16);
                    const b = parseInt(h.substring(4,6),16);
                    const nr = Math.round(r * (1 - frac));
                    const ng = Math.round(g * (1 - frac));
                    const nb = Math.round(b * (1 - frac));
                    return `#${toHex(nr)}${toHex(ng)}${toHex(nb)}`;
                }catch(e){ return hex; }
            }

            // returns true if color is very dark (near black)
            function isVeryDark(hex){
                try{
                    const h = hex.replace('#','');
                    const r = parseInt(h.substring(0,2),16);
                    const g = parseInt(h.substring(2,4),16);
                    const b = parseInt(h.substring(4,6),16);
                    const lum = 0.299*r + 0.587*g + 0.114*b;
                    return lum < 40; // threshold for 'very dark'
                }catch(e){ return false; }
            }

            function tempColor(val){
                if(val == null) return '#888888';
                const v = Number(val);
                // Map 20 -> pale green/white, 40 -> dark red. Quantize into 20 steps.
                const min = 20, max = 40;
                let p = (v - min) / (max - min);
                p = Math.max(0, Math.min(1, p));
                // quantize into 20 levels
                const steps = 20;
                p = Math.round(p * steps) / steps;
                // start color: pale green-white (#e8f6ef), end color: dark red (#8b0000)
                const r1 = parseInt('e8',16), g1 = parseInt('f6',16), b1 = parseInt('ef',16);
                const r2 = parseInt('8b',16), g2 = parseInt('00',16), b2 = parseInt('00',16);
                const r = r1 + (r2 - r1) * p;
                const g = g1 + (g2 - g1) * p;
                const b = b1 + (b2 - b1) * p;
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }

            function humColor(val){
                if(val == null) return '#888888';
                const v = Number(val);
                // Map 40 -> light sky-blue, 100 -> dark blue
                const min = 40, max = 100;
                let p = (v - min) / (max - min);
                p = Math.max(0, Math.min(1, p));
                // start #d9f6ff (very light sky blue), end #005fa3 (dark blue)
                const r1 = parseInt('d9',16), g1 = parseInt('f6',16), b1 = parseInt('ff',16);
                const r2 = parseInt('00',16), g2 = parseInt('5f',16), b2 = parseInt('a3',16);
                const r = r1 + (r2 - r1) * p;
                const g = g1 + (g2 - g1) * p;
                const b = b1 + (b2 - b1) * p;
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }

            function lightColor(val){
                if(val == null) return '#888888';
                const v = Number(val);
                // New mapping per user request:
                // 0..70: black -> white (interpolate)
                // >=70: white -> golden (#ffd200) (interpolate up to a cap)
                if(v <= 0) return '#000000';
                if(v <= 70){
                    const p = Math.max(0, Math.min(1, v / 70));
                    const r = 0 + (255 - 0) * p;
                    const g = 0 + (255 - 0) * p;
                    const b = 0 + (255 - 0) * p;
                    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                }
                // v > 70: interpolate from white -> golden (#ffd200)
                const start = 70;
                const cap = 2000; // reasonable cap for interpolation
                const p2 = Math.max(0, Math.min(1, (v - start) / (cap - start)));
                const r1 = 255, g1 = 255, b1 = 255; // white
                const r2 = parseInt('ff',16), g2 = parseInt('d2',16), b2 = parseInt('00',16); // #ffd200
                const r = r1 + (r2 - r1) * p2;
                const g = g1 + (g2 - g1) * p2;
                const b = b1 + (b2 - b1) * p2;
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }

            function applyColors(t,h,lx){
                // Apply color as background to the metric cards and keep number text contrasted
                try{
                    const tempCardEl = document.querySelector('.temp-card');
                    const humCardEl = document.querySelector('.hum-card');
                    const lightCardEl = document.querySelector('.light-card');
                    const tempValEl = document.getElementById('temperature');
                    const humValEl = document.getElementById('humidity');
                    const lightValEl = document.getElementById('lightLevel');

                    if(tempCardEl){
                        const c = (t != null) ? tempColor(t) : '#f0f0f0';
                        tempCardEl.style.background = c;
                        // border slightly darker
                        tempCardEl.style.borderColor = c;
                        if(tempValEl) tempValEl.style.color = getContrastColor(c);
                    }
                    if(humCardEl){
                        const c = (h != null) ? humColor(h) : '#f0f0f0';
                        humCardEl.style.background = c;
                        humCardEl.style.borderColor = c;
                        if(humValEl) humValEl.style.color = getContrastColor(c);
                    }
                    if(lightCardEl){
                        const c = (lx != null) ? lightColor(lx) : '#f0f0f0';
                        lightCardEl.style.background = c;
                        // use a slightly darker border for better visibility
                        lightCardEl.style.borderColor = darkenHex(c, 0.12);
                        if(lightValEl) {
                            // when the background is very dark (black-ish), force white text for readability
                            const forced = isVeryDark(c) ? '#ffffff' : getContrastColor(c);
                            lightValEl.style.color = forced;
                        }
                    }
                }catch(e){ console.error(e); }
            }

            // choose black/white text depending on background luminance
            function getContrastColor(hex){
                try{
                    // strip #
                    const h = hex.replace('#','');
                    const r = parseInt(h.substring(0,2),16);
                    const g = parseInt(h.substring(2,4),16);
                    const b = parseInt(h.substring(4,6),16);
                    const lum = 0.299*r + 0.587*g + 0.114*b;
                    return lum > 186 ? '#000000' : '#ffffff';
                }catch(e){ return '#000'; }
            }

            function update(d) {
                // ch·∫•p nh·∫≠n c·∫£ hai ki·ªÉu t√™n field
                const t  = d.temperature ?? d.temp;
                const h  = d.humidity    ?? d.hum;
                const lx = d.lightLevel  ?? d.lux;
                const r  = d.rain;
                const w  = d.windy;
                const ts = d.timestamp   ?? d.ts;

                if (t != null && window.temperature) window.temperature.textContent = t;
                if (h != null && window.humidity) window.humidity.textContent = h;
                if (lx != null && window.lightLevel) window.lightLevel.textContent = lx;
                if (r != null && window.rain) window.rain.textContent = r;
                if (w != null && window.windy) window.windy.textContent = w;
                if (window.timestamp) window.timestamp.textContent = ts ?? '--';

                const label = fmtTime(ts);
                // push combined point: [temp, humidity, light, rain, windy]
                pushPoint(tempHumChart, label, [t != null ? t : null, h != null ? h : null, lx != null ? lx : null, r != null ? r : null, w != null ? w : null]);
                // apply colors on each update
                applyColors(t, h, lx);
            }


            // apply initial colors from last server seed
            (function(){
                const last = serverSeed.length ? serverSeed[serverSeed.length - 1] : null;
                if(last){
                    const lt = last.temperature ?? last.temp;
                    const lh = last.humidity ?? last.hum;
                    const ll = last.lightLevel ?? last.lux;
                    applyColors(lt, lh, ll);
                }
            })();

        });


        // Helper functions for loading state
        function showLoadingState(device) {
            const switchEl = document.querySelector(`#${device}Toggle`).closest('.switch');
            const sliderEl = switchEl?.querySelector('.slider');
            if (sliderEl) {
                switchEl.classList.add('loading');
                // Add spinner element to slider if not exists
                if (!sliderEl.querySelector('.loading-spinner')) {
                    const spinner = document.createElement('div');
                    spinner.className = 'loading-spinner';
                    sliderEl.appendChild(spinner);
                }
            }
        }

        function hideLoadingState(device) {
            const switchEl = document.querySelector(`#${device}Toggle`).closest('.switch');
            const sliderEl = switchEl?.querySelector('.slider');
            if (switchEl && sliderEl) {
                switchEl.classList.remove('loading');
                const spinner = sliderEl.querySelector('.loading-spinner');
                if (spinner) {
                    spinner.remove();
                }
            }
        }

        // g·ª≠i l·ªánh b·∫≠t/t·∫Øt device
        async function toggleDevice(device, newCheckedState) {
            const room = 'room1';
            const action = newCheckedState ? 'on' : 'off';
            const url = `/dashboard/command?room=${room}&device=${device}&action=${action}`;

            const statusEl = document.getElementById('cmdStatus');
            updateDeviceIcon(device, newCheckedState);
            
            // Show loading state
            showLoadingState(device);
            if (statusEl) statusEl.textContent = `ƒêang g·ª≠i: ${device} -> ${action}...`;

            try {
                const res = await fetch(url, { 
                    method: 'POST',
                    headers: {
                        'Accept': 'text/plain'
                    }
                });
                if (res.ok) {
                    if (statusEl) statusEl.textContent = `‚úì ƒê√£ g·ª≠i l·ªánh ${device} -> ${action}`;
                    console.log(`[Command] Sent ${device} -> ${action}, waiting 0.5s before refresh`);
                    setTimeout(() => {
                        forceRefreshState();
                        hideLoadingState(device);
                    }, 500);
                } else {
                    hideLoadingState(device);
                    if (statusEl) statusEl.textContent = `L·ªói ${res.status}`;
                    // Kh√¥i ph·ª•c checkbox v√† icon v·ªÅ tr·∫°ng th√°i c≈©
                    const toggleEl = document.getElementById(device + 'Toggle');
                    if (toggleEl) {
                        toggleEl.checked = !newCheckedState;
                        updateDeviceIcon(device, !newCheckedState); // Rollback icon
                    }
                }
            } catch (e) {
                hideLoadingState(device);
                if (statusEl) statusEl.textContent = 'G·ª≠i l·ªánh th·∫•t b·∫°i!';
                console.error(e);
                // Kh√¥i ph·ª•c checkbox v√† icon v·ªÅ tr·∫°ng th√°i c≈©
                const toggleEl = document.getElementById(device + 'Toggle');
                if (toggleEl) {
                    toggleEl.checked = !newCheckedState;
                    updateDeviceIcon(device, !newCheckedState); // Rollback icon
                }
            }
        }

        // ki·ªÉm tra esp ƒë√£ g·ªßi th√¥ng b√°o c·∫≠p nh·∫≠t tr·∫°ng th√°i device ch∆∞a
        async function pollDeviceState(device, expectedAction, maxAttempts) {
            let attempts = 0;
            console.log(`[Poll] Start polling ${device}, expecting: ${expectedAction}`);
            
            const pollInterval = setInterval(async () => {
                attempts++;
                try {
                    const res = await fetch('/dashboard/state');
                    if (res.ok) {
                        const state = await res.json();
                        console.log(`[Poll] Raw state response:`, state);
                        const currentState = state[device]?.toLowerCase();
                        
                        console.log(`[Poll] Attempt ${attempts}/${maxAttempts} - ${device} current state: ${currentState}, expected: ${expectedAction}`);
                        
                        if (currentState === expectedAction) {
                            // ESP ƒë√£ x√°c nh·∫≠n, c·∫≠p nh·∫≠t icon
                            clearInterval(pollInterval);
                            const isOn = (expectedAction === 'on');
                            updateDeviceIcon(device, isOn);
                            
                            const statusEl = document.getElementById('cmdStatus');
                            if (statusEl) statusEl.textContent = `‚úì ${device} ƒë√£ ${isOn ? 'B·∫¨T' : 'T·∫ÆT'}`;
                            console.log(`[Poll] Success! ${device} confirmed ${expectedAction}`);
                            return;
                        }
                    }
                } catch (e) {
                    console.error('[Poll] Error:', e);
                }
                
                if (attempts >= maxAttempts) {
                    clearInterval(pollInterval);
                    const statusEl = document.getElementById('cmdStatus');
                    if (statusEl) statusEl.textContent = `‚ö† ${device} kh√¥ng ph·∫£n h·ªìi - ki·ªÉm tra ESP`;
                    console.log(`[Poll] Timeout after ${maxAttempts} attempts`);
                }
            }, 500); // Poll m·ªói 500ms
        }

        // c·∫≠p nh·∫≠t tr·∫°ng th√°i icons
        function updateDeviceIcon(device, isOn) {
            console.log(`[Icon Update] ${device} -> ${isOn ? 'ON' : 'OFF'}`);
            
            const ids = { air: 'airIcon', fan: 'fanIcon', light: 'lightIcon' };
            const paths = {
                air:   { on: '/images/AirCon_Active.png', off: '/images/AirCon_Not.png' },
                fan:   { on: '/images/Fan_Act.png',       off: '/images/Fan_notAc.png' },
                light: { on: '/images/Light_act.png',     off: '/images/Light_notAct.png' }
            };
            const elId = ids[device];
            const imgEl = elId ? document.getElementById(elId) : null;
            
            if (!imgEl) {
                console.error(`[Icon Update] Element not found for device: ${device}, expected ID: ${elId}`);
                return;
            }

            console.log(`[Icon Update] Found element for ${device}, current src: ${imgEl.src}`);

            // Remove existing classes
            imgEl.classList.remove('active', 'inactive', 'transitioning');
            
            // Add transitioning class for animation
            imgEl.classList.add('transitioning');
            
            // Scale down and fade effect
            imgEl.style.transform = 'scale(0.8) rotate(-5deg)';
            imgEl.style.opacity = '0.3';
            
            setTimeout(() => {
                const p = paths[device];
                if (!p) {
                    console.error(`[Icon Update] No paths found for device: ${device}`);
                    return;
                }
                
                const newSrc = isOn ? p.on : p.off;
                console.log(`[Icon Update] Changing ${device} src from ${imgEl.src} to ${newSrc}`);
                
                // Change image source
                imgEl.src = newSrc;
                
                // Reset transform and apply new state
                imgEl.style.transform = '';
                imgEl.style.opacity = '1';
                
                // Add appropriate state class
                imgEl.classList.add(isOn ? 'active' : 'inactive');
                console.log(`[Icon Update] Applied class: ${isOn ? 'active' : 'inactive'} to ${device}`);
                
                // Remove transitioning class after animation
                setTimeout(() => {
                    imgEl.classList.remove('transitioning');
                }, 600);
                
            }, 200);
        }
        
        // √©p refresh tr·∫°ng th√°i thi·∫øt b·ªã t·ª´ server
        async function forceRefreshState() {
            console.log('[Refresh] Fetching current device states...');
            try {
                const res = await fetch('/dashboard/state');
                if (res.ok) {
                    const state = await res.json();
                    console.log('[Refresh] State:', state);
                    
                    // Update all checkboxes and clear loading states
                    ['air', 'fan', 'light'].forEach(device => {
                        hideLoadingState(device); // Clear any loading state
                        const toggleEl = document.getElementById(device + 'Toggle');
                        const currentState = state[device]?.toLowerCase();
                        const isOn = (currentState === 'on');
                        
                        if (toggleEl) {
                            toggleEl.checked = isOn;
                            toggleEl.disabled = false;
                            console.log(`[Refresh] ${device}: ${currentState}, checkbox set to ${toggleEl.checked}`);
                        }
                        
                        // Force icon update with current state
                        console.log(`[Refresh] Calling updateDeviceIcon for ${device} with state ${isOn}`);
                        updateDeviceIcon(device, isOn);
                    });
                    
                    const statusEl = document.getElementById('cmdStatus');
                    if (statusEl) statusEl.textContent = '‚úì ƒê√£ refresh tr·∫°ng th√°i thi·∫øt b·ªã';
                }
            } catch (e) {
                console.error('[Refresh] Error:', e);
                // Clear loading states even on error
                ['air', 'fan', 'light'].forEach(device => hideLoadingState(device));
            }
        }
        /*]]>*/
    </script>
</body>
</html>

